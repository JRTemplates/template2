{"dependencies":[],"generated":{"js":"var _ = module.exports = {};\nvar slice = [].slice, o2str = ({}).toString;\n\n// merge o2's properties to Object o1. \n_.extend = function(o1, o2, override){\n  for(var i in o2) if(override || o1[i] === undefined){\n    o1[i] = o2[i];\n  }\n  return o1;\n};\n\nvar rDot = /\\./g;\n_.countDot = function(word){\n  var ret = word.match(rDot)\n  return ret? ret.length: 0;\n}\n\n_.values = function( o, key){\n  var keys = [];\n  for(var i in o) if( o.hasOwnProperty(i) ){\n    keys.push( key? i: o[i] );\n  }\n  return keys;\n};\n\n_.inherit = function( cstor, o ){\n  function Faker(){}\n  Faker.prototype = o;\n  cstor.prototype = new Faker();\n  cstor.prototype.constructor = cstor;\n  return o;\n}\n\n_.slice = function(arr, index){\n  return slice.call(arr, index);\n};\n\n_.typeOf = function typeOf (o) {\n  return o == null ? String(o) : o2str.call(o).slice(8, -1).toLowerCase();\n};\n\n//strict eql\n_.eql = function(o1, o2){\n  var t1 = _.typeOf(o1), t2 = _.typeOf(o2);\n  if( t1 !== t2) return false;\n  if(t1 === 'object'){\n    // only check the first's properties\n    for(var i in o1){\n      // Immediately return if a mismatch is found.\n      if( o1[i] !== o2[i] ) return false;\n    }\n    return true;\n  }\n  return o1 === o2;\n};\n\n// small emitter \n_.emitable = (function(){\n  function norm(ev){\n    var eventAndNamespace = (ev||'').split(':');\n    return {event: eventAndNamespace[0], namespace: eventAndNamespace[1]};\n  }\n  var API = {\n    once: function(event, fn){\n      var callback = function(){\n        fn.apply(this, arguments);\n        this.off(event, callback);\n      };\n      return this.on(event, callback);\n    },\n    on: function(event, fn) {\n      if(typeof event === 'object'){\n        for (var i in event) {\n          this.on(i, event[i]);\n        }\n        return this;\n      }\n      var ne = norm(event);\n      event=ne.event;\n      if(event && typeof fn === 'function' ){\n        var handles = this._handles || (this._handles = {}),\n          calls = handles[event] || (handles[event] = []);\n        fn._ns = ne.namespace;\n        calls.push(fn);\n      }\n      return this;\n    },\n    off: function(event, fn) {\n      var ne = norm(event); event = ne.event;\n      if(!event || !this._handles) this._handles = {};\n\n      var handles = this._handles;\n      var calls = handles[event];\n\n      if (calls) {\n        if (!fn && !ne.namespace) {\n          handles[event] = [];\n        }else{\n          for (var i = 0, len = calls.length; i < len; i++) {\n            if ( (!fn || fn === calls[i]) && (!ne.namespace || calls[i]._ns === ne.namespace) ) {\n              calls.splice(i, 1);\n              return this;\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    emit: function(event){\n      var ne = norm(event); event = ne.event;\n\n      var args = _.slice(arguments, 1),\n        handles = this._handles, calls;\n\n      if (!handles || !(calls = handles[event])) return this;\n      for (var i = 0, len = calls.length; i < len; i++) {\n        var fn = calls[i];\n        if( !ne.namespace || fn._ns === ne.namespace ) fn.apply(this, args);\n      }\n      return this;\n    }\n  };\n  return function(obj){\n      obj = typeof obj == \"function\" ? obj.prototype : obj;\n      return _.extend(obj, API);\n  };\n})();\n\n_.bind = function(fn, context){\n  return function(){\n    return fn.apply(context, arguments);\n  };\n};\n\nvar rDbSlash = /\\/+/g, // double slash\n  rEndSlash = /\\/$/;    // end slash\n\n_.cleanPath = function (path){\n  return (\"/\" + path).replace( rDbSlash,\"/\" ).replace( rEndSlash, \"\" ) || \"/\";\n};\n\n// normalize the path\nfunction normalizePath(path) {\n  // means is from \n  // (?:\\:([\\w-]+))?(?:\\(([^\\/]+?)\\))|(\\*{2,})|(\\*(?!\\*)))/g\n  var preIndex = 0;\n  var keys = [];\n  var index = 0;\n  var matches = \"\";\n\n  path = _.cleanPath(path);\n\n  var regStr = path\n    //  :id(capture)? | (capture)   |  ** | * \n    .replace(/\\:([\\w-]+)(?:\\(([^\\/]+?)\\))?|(?:\\(([^\\/]+)\\))|(\\*{2,})|(\\*(?!\\*))/g, \n      function(all, key, keyformat, capture, mwild, swild, startAt) {\n        // move the uncaptured fragment in the path\n        if(startAt > preIndex) matches += path.slice(preIndex, startAt);\n        preIndex = startAt + all.length;\n        if( key ){\n          matches += \"(\" + key + \")\";\n          keys.push(key);\n          return \"(\"+( keyformat || \"[\\\\w-]+\")+\")\";\n        }\n        matches += \"(\" + index + \")\";\n\n        keys.push( index++ );\n\n        if( capture ){\n           // sub capture detect\n          return \"(\" + capture +  \")\";\n        } \n        if(mwild) return \"(.*)\";\n        if(swild) return \"([^\\\\/]*)\";\n    });\n\n  if(preIndex !== path.length) matches += path.slice(preIndex);\n\n  return {\n    regexp: new RegExp(\"^\" + regStr +\"/?$\"),\n    keys: keys,\n    matches: matches || path\n  };\n}\n\n_.log = function(msg, type){\n  typeof console !== \"undefined\" && console[type || \"log\"](msg); //eslint-disable-line no-console\n};\n\n_.isPromise = function( obj ){\n\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n\n};\n\n_.normalize = normalizePath;\n"},"hash":"6c03c00723df29df5b9bb4ed186a7157"}