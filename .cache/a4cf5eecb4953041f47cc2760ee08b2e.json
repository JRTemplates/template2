{"dependencies":[{"name":"../env","loc":{"line":5,"column":18}},{"name":"../parser/Lexer","loc":{"line":6,"column":20}},{"name":"../parser/Parser","loc":{"line":7,"column":21}},{"name":"../config","loc":{"line":8,"column":21}},{"name":"../util","loc":{"line":9,"column":16}},{"name":"../helper/extend","loc":{"line":10,"column":21}},{"name":"./shared","loc":{"line":26,"column":21}},{"name":"../dom","loc":{"line":14,"column":20}},{"name":"../walkers","loc":{"line":15,"column":24}},{"name":"../group","loc":{"line":16,"column":22}},{"name":"../helper/combine","loc":{"line":18,"column":20}},{"name":"../helper/event","loc":{"line":20,"column":21}},{"name":"../helper/watcher","loc":{"line":21,"column":22}},{"name":"../helper/parse","loc":{"line":22,"column":20}},{"name":"../helper/filter","loc":{"line":23,"column":21}},{"name":"../const","loc":{"line":24,"column":20}},{"name":"../helper/cursor","loc":{"line":25,"column":25}}],"generated":{"js":"/**\n * render for component in browsers\n */\n\nvar env = require('../env');\nvar Lexer = require('../parser/Lexer');\nvar Parser = require('../parser/Parser');\nvar config = require('../config');\nvar _ = require('../util');\nvar extend = require('../helper/extend');\nvar shared = require('./shared');\nvar combine = {};\nif(env.browser){\n  var dom = require(\"../dom\");\n  var walkers = require('../walkers');\n  var Group = require('../group');\n  var doc = dom.doc;\n  combine = require('../helper/combine');\n}\nvar events = require('../helper/event');\nvar Watcher = require('../helper/watcher');\nvar parse = require('../helper/parse');\nvar filter = require('../helper/filter');\nvar ERROR = require('../const').ERROR;\nvar nodeCursor = require('../helper/cursor');\nvar shared = require('./shared');\nvar NOOP = function(){};\n\n\n/**\n* `Regular` is regularjs's NameSpace and BaseClass. Every Component is inherited from it\n* \n* @class Regular\n* @module Regular\n* @constructor\n* @param {Object} options specification of the component\n*/\nvar Regular = function(definition, options){\n  var prevRunning = env.isRunning;\n  env.isRunning = true;\n  var node, template, cursor, context = this, body, mountNode;\n  options = options || {};\n  definition = definition || {};\n\n\n\n  var dtemplate = definition.template;\n\n  if(env.browser) {\n\n    if( node = tryGetSelector( dtemplate ) ){\n      dtemplate = node;\n    }\n    if( dtemplate && dtemplate.nodeType ){\n      definition.template = dtemplate.innerHTML\n    }\n    \n    mountNode = definition.mountNode;\n    if(typeof mountNode === 'string'){\n      mountNode = dom.find( mountNode );\n      if(!mountNode) throw Error('mountNode ' + mountNode + ' is not found')\n    } \n\n    if(mountNode){\n      cursor = nodeCursor(mountNode.firstChild, mountNode)\n      delete definition.mountNode\n    }else{\n      cursor = options.cursor\n    }\n  }\n\n\n\n  template = shared.initDefinition(context, definition)\n  \n\n  if(context.$parent){\n     context.$parent._append(context);\n  }\n  context._children = [];\n  context.$refs = {};\n  context.$root = context.$root || context;\n\n  var extra = options.extra;\n  var oldModify = extra && extra.$$modify;\n\n  \n  var newExtra;\n  if( body = context._body ){\n    context._body = null\n    var modifyBodyComponent = context.modifyBodyComponent;\n    if( typeof modifyBodyComponent  === 'function'){\n      modifyBodyComponent = modifyBodyComponent.bind(this)\n      newExtra = _.createObject(extra);\n      newExtra.$$modify = function( comp ){\n        return modifyBodyComponent(comp, oldModify? oldModify: NOOP)\n      }\n    }else{ //@FIXIT: multiply modifier\n      newExtra = extra\n    }\n    if(body.ast && body.ast.length){\n      context.$body = _.getCompileFn(body.ast, body.ctx , {\n        outer: context,\n        namespace: options.namespace,\n        extra: newExtra,\n        record: true\n      })\n    }\n  }\n\n  // handle computed\n  if(template){\n    var cplOpt = {\n      namespace: options.namespace,\n      cursor: cursor\n    }\n    // if(extra && extra.$$modify){\n      cplOpt.extra = {$$modify : extra&& extra.$$modify}\n    // }\n    context.group = context.$compile(template, cplOpt);\n    combine.node(context);\n  }\n\n\n\n  // modify在compile之后调用， 这样就无需处理SSR相关逻辑\n  \n  if( oldModify ){\n    oldModify(this);\n  }\n\n  // this is outest component\n  if( !context.$parent ) context.$update();\n  context.$ready = true;\n\n  context.$emit(\"$init\");\n  if( context.init ) context.init( context.data );\n  context.$emit(\"$afterInit\");\n\n  env.isRunning = prevRunning;\n\n  // children is not required;\n  \n  if (this.devtools) {\n    this.devtools.emit(\"init\", this)\n  }\n}\n\n// check if regular devtools hook exists\nif(typeof window !== 'undefined'){\n  var devtools = window.__REGULAR_DEVTOOLS_GLOBAL_HOOK__;\n  if (devtools) {\n    Regular.prototype.devtools = devtools;\n  }\n}\n\nwalkers && (walkers.Regular = Regular);\n\n\n// description\n// -------------------------\n// 1. Regular and derived Class use same filter\n_.extend(Regular, {\n  // private data stuff\n  _directives: { __regexp__:[] },\n  _plugins: {},\n  _protoInheritCache: [ 'directive', 'use'] ,\n  __after__: function(supr, o) {\n\n    var template;\n    this.__after__ = supr.__after__;\n\n    // use name make the component global.\n    if(o.name) Regular.component(o.name, this);\n    // this.prototype.template = dom.initTemplate(o)\n    if(template = o.template){\n      var node, name;\n      if( env.browser ){\n        if( node = tryGetSelector(template) ) template = node ;\n        if( template && template.nodeType ){\n\n          if(name = dom.attr(template, 'name')) Regular.component(name, this);\n\n          template = template.innerHTML;\n        } \n      }\n\n      if(typeof template === 'string' ){\n        this.prototype.template = config.PRECOMPILE? new Parser(template).parse(): template;\n      }\n    }\n\n    if(o.computed) this.prototype.computed = shared.handleComputed(o.computed);\n    // inherit directive and other config from supr\n    Regular._inheritConfig(this, supr);\n\n  },\n  /**\n   * Define a directive\n   *\n   * @method directive\n   * @return {Object} Copy of ...\n   */  \n  directive: function(name, cfg){\n    if(!name) return;\n\n    var type = typeof name;\n    if(type === 'object' && !cfg){\n      for(var k in name){\n        if(name.hasOwnProperty(k)) this.directive(k, name[k]);\n      }\n      return this;\n    }\n    var directives = this._directives, directive;\n    if(cfg == null){\n      if( type === 'string' ){\n        if( directive = directives[name] ) return directive;\n        else{\n          var regexp = directives.__regexp__;\n          for(var i = 0, len = regexp.length; i < len ; i++){\n            directive = regexp[i];\n            var test = directive.regexp.test(name);\n            if(test) return directive;\n          }\n        }\n      }\n    }else{\n      if( typeof cfg === 'function') cfg = { link: cfg } \n      if( type === 'string' ) directives[name] = cfg;\n      else{\n        cfg.regexp = name;\n        directives.__regexp__.push(cfg)\n      }\n      return this\n    }\n  },\n  plugin: function(name, fn){\n    var plugins = this._plugins;\n    if(fn == null) return plugins[name];\n    plugins[name] = fn;\n    return this;\n  },\n  use: function(fn){\n    if(typeof fn === \"string\") fn = Regular.plugin(fn);\n    if(typeof fn !== \"function\") return this;\n    fn(this, Regular);\n    return this;\n  },\n  // config the Regularjs's global\n  config: function(name, value){\n    var needGenLexer = false;\n    if(typeof name === \"object\"){\n      for(var i in name){\n        // if you config\n        if( i ===\"END\" || i==='BEGIN' )  needGenLexer = true;\n        config[i] = name[i];\n      }\n    }\n    if(needGenLexer) Lexer.setup();\n  },\n  expression: parse.expression,\n  Parser: Parser,\n  Lexer: Lexer,\n  _addProtoInheritCache: function(name, transform){\n    if( Array.isArray( name ) ){\n      return name.forEach(Regular._addProtoInheritCache);\n    }\n    var cacheKey = \"_\" + name + \"s\"\n    Regular._protoInheritCache.push(name)\n    Regular[cacheKey] = {};\n    if(Regular[name]) return;\n    Regular[name] = function(key, cfg){\n      var cache = this[cacheKey];\n\n      if(typeof key === \"object\"){\n        for(var i in key){\n          if(key.hasOwnProperty(i)) this[name](i, key[i]);\n        }\n        return this;\n      }\n      if(cfg == null) return cache[key];\n      cache[key] = transform? transform(cfg) : cfg;\n      return this;\n    }\n  },\n  _inheritConfig: function(self, supr){\n\n    // prototype inherit some Regular property\n    // so every Component will have own container to serve directive, filter etc..\n    var defs = Regular._protoInheritCache;\n    var keys = _.slice(defs);\n    keys.forEach(function(key){\n      self[key] = supr[key];\n      var cacheKey = '_' + key + 's';\n      if(supr[cacheKey]) self[cacheKey] = _.createObject(supr[cacheKey]);\n    })\n    return self;\n  }\n\n});\n\nextend(Regular);\n\nRegular._addProtoInheritCache(\"component\")\n\nRegular._addProtoInheritCache(\"filter\", function(cfg){\n  return typeof cfg === \"function\"? {get: cfg}: cfg;\n})\n\n\nevents.mixTo(Regular);\nWatcher.mixTo(Regular);\n\nRegular.implement({\n  init: function(){},\n  config: function(){},\n  destroy: function(){\n    // destroy event wont propgation;\n    this.$emit(\"$destroy\");\n    this._watchers = null;\n    this._watchersForStable = null;\n    this.group && this.group.destroy(true);\n    this.group = null;\n    this.parentNode = null;\n    this._children = null;\n    this.$root = null;\n    this._handles = null;\n    this.$refs = null;\n    var parent = this.$parent;\n    if(parent && parent._children){\n      var index = parent._children.indexOf(this);\n      parent._children.splice(index,1);\n    }\n    this.$parent = null;\n\n    if (this.devtools) {\n      this.devtools.emit(\"destroy\", this)\n    }\n    this._handles = null;\n    this.$phase = \"destroyed\";\n  },\n\n  /**\n   * compile a block ast ; return a group;\n   * @param  {Array} parsed ast\n   * @param  {[type]} record\n   * @return {[type]}\n   */\n  $compile: function(ast, options){\n    options = options || {};\n    if(typeof ast === 'string'){\n      ast = new Parser(ast).parse()\n    }\n    var preExt = this.__ext__,\n      record = options.record, \n      records;\n\n    if(options.extra) this.__ext__ = options.extra;\n\n\n    if(record) this._record();\n    var group = this._walk(ast, options);\n    if(record){\n      records = this._release();\n      var self = this;\n      if( records.length ){\n        // auto destroy all wather;\n        group.ondestroy = function(){ self.$unwatch(records); }\n      }\n    }\n    if(options.extra) this.__ext__ = preExt;\n    return group;\n  },\n\n\n  /**\n   * create two-way binding with another component;\n   * *warn*: \n   *   expr1 and expr2 must can operate set&get, for example: the 'a.b' or 'a[b + 1]' is set-able, but 'a.b + 1' is not, \n   *   beacuse Regular dont know how to inverse set through the expression;\n   *   \n   *   if before $bind, two component's state is not sync, the component(passed param) will sync with the called component;\n   *\n   * *example: *\n   *\n   * ```javascript\n   * // in this example, we need to link two pager component\n   * var pager = new Pager({}) // pager compoennt\n   * var pager2 = new Pager({}) // another pager component\n   * pager.$bind(pager2, 'current'); // two way bind throw two component\n   * pager.$bind(pager2, 'total');   // \n   * // or just\n   * pager.$bind(pager2, {\"current\": \"current\", \"total\": \"total\"}) \n   * ```\n   * \n   * @param  {Regular} component the\n   * @param  {String|Expression} expr1     required, self expr1 to operate binding\n   * @param  {String|Expression} expr2     optional, other component's expr to bind with, if not passed, the expr2 will use the expr1;\n   * @return          this;\n   */\n  $bind: function(component, expr1, expr2){\n    var type = _.typeOf(expr1);\n    if( expr1.type === 'expression' || type === 'string' ){\n      this._bind(component, expr1, expr2)\n    }else if( type === \"array\" ){ // multiply same path binding through array\n      for(var i = 0, len = expr1.length; i < len; i++){\n        this._bind(component, expr1[i]);\n      }\n    }else if(type === \"object\"){\n      for(var i in expr1) if(expr1.hasOwnProperty(i)){\n        this._bind(component, i, expr1[i]);\n      }\n    }\n    // digest\n    component.$update();\n    return this;\n  },\n  /**\n   * unbind one component( see $bind also)\n   *\n   * unbind will unbind all relation between two component\n   * \n   * @param  {Regular} component [descriptionegular\n   * @return {This}    this\n   */\n  $unbind: function(){\n    // todo\n  },\n  $inject: combine.inject,\n  $mute: function(isMute){\n\n    isMute = !!isMute;\n\n    var needupdate = isMute === false && this._mute;\n\n    this._mute = !!isMute;\n\n    if(needupdate) this.$update();\n    return this;\n  },\n  // private bind logic\n  _bind: function(component, expr1, expr2){\n\n    var self = this;\n    // basic binding\n\n    if(!component || !(component instanceof Regular)) throw \"$bind() should pass Regular component as first argument\";\n    if(!expr1) throw \"$bind() should  pass as least one expression to bind\";\n\n    if(!expr2) expr2 = expr1;\n\n    expr1 = parse.expression( expr1 );\n    expr2 = parse.expression( expr2 );\n\n    // set is need to operate setting ;\n    if(expr2.set){\n      var wid1 = this.$watch( expr1, function(value){\n        component.$update(expr2, value)\n      });\n      component.$on('$destroy', function(){\n        self.$unwatch(wid1)\n      })\n    }\n    if(expr1.set){\n      var wid2 = component.$watch(expr2, function(value){\n        self.$update(expr1, value)\n      });\n      // when brother destroy, we unlink this watcher\n      this.$on('$destroy', component.$unwatch.bind(component,wid2))\n    }\n    // sync the component's state to called's state\n    expr2.set(component, expr1.get(this));\n  },\n  _walk: function(ast, options){\n    if( Array.isArray(ast) ){\n      var res = [];\n\n      for(var i = 0, len = ast.length; i < len; i++){\n        var ret = this._walk(ast[i], options);\n        if(ret && ret.code === ERROR.UNMATCHED_AST){\n          ast.splice(i, 1);\n          i--;\n          len--;\n        }else res.push( ret );\n      }\n      return new Group(res);\n    }\n    if(typeof ast === 'string') return doc.createTextNode(ast)\n    return walkers[ast.type || \"default\"].call(this, ast, options);\n  },\n  _append: function(component){\n    this._children.push(component);\n    component.$parent = this;\n  },\n  _handleEvent: function(elem, type, value, attrs){\n    var Component = this.constructor,\n      fire = typeof value !== \"function\"? _.handleEvent.call( this, value, type ) : value,\n      handler = Component.event(type), destroy;\n\n    if ( handler ) {\n      destroy = handler.call(this, elem, fire, attrs);\n    } else {\n      dom.on(elem, type, fire);\n    }\n    return handler ? destroy : function() {\n      dom.off(elem, type, fire);\n    }\n  },\n  // 1. 用来处理exprBody -> Function\n  // 2. list里的循环\n  _touchExpr: function(expr, ext){\n    var rawget, ext = this.__ext__, touched = {};\n    if(expr.type !== 'expression' || expr.touched) return expr;\n\n    rawget = expr.get;\n    if(!rawget){\n      rawget = expr.get = new Function(_.ctxName, _.extName , _.prefix+ \"return (\" + expr.body + \")\");\n      expr.body = null;\n    }\n    touched.get = !ext? rawget: function(context, e){\n      return rawget( context, e || ext )\n    }\n\n    if(expr.setbody && !expr.set){\n      var setbody = expr.setbody;\n      var filters = expr.filters;\n      var self = this;\n      if(!filters || !_.some(filters, function(filter){ return !self._f_(filter).set }) ){\n        expr.set = function(ctx, value, ext){\n          expr.set = new Function(_.ctxName, _.setName , _.extName, _.prefix + setbody);          \n          return expr.set(ctx, value, ext);\n        }\n      }\n      expr.filters = expr.setbody = null;\n    }\n    if(expr.set){\n      touched.set = !ext? expr.set : function(ctx, value){\n        return expr.set(ctx, value, ext);\n      }\n    }\n\n    touched.type = 'expression';\n    touched.touched = true;\n    touched.once = expr.once || expr.constant;\n    return touched\n  },\n  // find filter\n  _f_: function(name){\n    var Component = this.constructor;\n    var filter = Component.filter(name);\n    if(!filter) throw Error('filter ' + name + ' is undefined');\n    return filter;\n  },\n  // simple accessor get\n  _sg_:function(path, defaults, ext){\n    if( path === undefined ) return undefined;\n    if(ext && typeof ext === 'object'){\n      if(ext[path] !== undefined)  return ext[path];\n    }\n    var computed = this.computed,\n      computedProperty = computed[path];\n    if(computedProperty){\n      if(computedProperty.type==='expression' && !computedProperty.get) this._touchExpr(computedProperty);\n      if(computedProperty.get)  return computedProperty.get(this);\n      else _.log(\"the computed '\" + path + \"' don't define the get function,  get data.\"+path + \" altnately\", \"warn\")\n    }\n\n    if( defaults === undefined  ){\n      return undefined;\n    }\n    return defaults[path];\n\n  },\n  // simple accessor set\n  _ss_:function(path, value, data , op, computed){\n    var computed = this.computed,\n      op = op || \"=\", prev, \n      computedProperty = computed? computed[path]:null;\n\n    if(op !== '='){\n      prev = computedProperty? computedProperty.get(this): data[path];\n      switch(op){\n        case \"+=\":\n          value = prev + value;\n          break;\n        case \"-=\":\n          value = prev - value;\n          break;\n        case \"*=\":\n          value = prev * value;\n          break;\n        case \"/=\":\n          value = prev / value;\n          break;\n        case \"%=\":\n          value = prev % value;\n          break;\n      }\n    }\n    if(computedProperty) {\n      if(computedProperty.set) return computedProperty.set(this, value);\n      else _.log(\"the computed '\" + path + \"' don't define the set function,  assign data.\"+path + \" altnately\", \"warn\" )\n    }\n    data[path] = value;\n    return value;\n  }\n});\n\nRegular.prototype.inject = function(){\n  _.log(\"use $inject instead of inject\", \"warn\");\n  return this.$inject.apply(this, arguments);\n}\n\n\n// only one builtin filter\n\nRegular.filter(filter);\n\nmodule.exports = Regular;\n\n\n\nfunction tryGetSelector(tpl){\n  var node;\n  if( typeof tpl === 'string' && tpl.length < 16 && (node = dom.find( tpl )) ) {\n    _.log(\"pass selector as template has be deprecated, pass node or template string instead\", 'warn')\n    return node\n  }\n}\n"},"hash":"ce45663cff79935f63b56af6aa215f49"}