{"dependencies":[{"name":"../state.js","loc":{"line":2,"column":20}},{"name":"../util.js","loc":{"line":3,"column":14}}],"generated":{"js":"\nvar State = require(\"../state.js\"),\n  _ = require(\"../util.js\"),\n  stateFn = State.prototype.state;\n\nfunction BaseMan( options ){\n\n  options = options || {};\n\n  this._states = {};\n\n  this.strict = options.strict;\n  this.title = options.title;\n\n  if(options.routes) this.state(options.routes);\n\n}\n\n_.extend( _.emitable( BaseMan ), {\n    // keep blank\n    name: '',\n\n    root: true,\n\n\n    state: function(stateName){\n\n      var active = this.active;\n      var args = _.slice(arguments, 1);\n\n      if(typeof stateName === \"string\" && active){\n         stateName = stateName.replace(\"~\", active.name);\n         if(active.parent) stateName = stateName.replace(\"^\", active.parent.name || \"\");\n      }\n      // ^ represent current.parent\n      // ~ represent  current\n      // only \n      args.unshift(stateName);\n      return stateFn.apply(this, args);\n\n    },\n\n    decode: function(path, needLocation){\n\n      var pathAndQuery = path.split(\"?\");\n      var query = this._findQuery(pathAndQuery[1]);\n      path = pathAndQuery[0];\n      var found = this._findState(this, path);\n      if(found) _.extend(found.param, query);\n      return found;\n\n    },\n    encode: function(stateName, param, needLink){\n      var state = this.state(stateName);\n      var history = this.history;\n      if(!state) return;\n      var url  = state.encode(param);\n      \n      return needLink? (history.mode!==2? history.prefix + url : url ): url;\n    },\n    // notify specify state\n    // check the active statename whether to match the passed condition (stateName and param)\n    is: function(stateName, param, isStrict){\n      if(!stateName) return false;\n      stateName = (stateName.name || stateName);\n      var current = this.current, currentName = current.name;\n      var matchPath = isStrict? currentName === stateName : (currentName + \".\").indexOf(stateName + \".\")===0;\n      return matchPath && (!param || _.eql(param, this.param)); \n    },\n\n\n    _wrapPromise: function( promise, next ){\n\n      return promise.then( next, function(){ next(false); }) ;\n\n    },\n\n    _findQuery: function(querystr){\n\n      var queries = querystr && querystr.split(\"&\"), query= {};\n      if(queries){\n        var len = queries.length;\n        for(var i =0; i< len; i++){\n          var tmp = queries[i].split(\"=\");\n          query[tmp[0]] = tmp[1];\n        }\n      }\n      return query;\n\n    },\n    _findState: function(state, path){\n      var states = state._states, found, param;\n\n      // leaf-state has the high priority upon branch-state\n      if(state.hasNext){\n\n        var stateList = _.values( states ).sort( this._sortState );\n        var len = stateList.length;\n\n        for(var i = 0; i < len; i++){\n\n          found = this._findState( stateList[i], path );\n          if( found ) return found;\n        }\n\n      }\n      // in strict mode only leaf can be touched\n      // if all children is don. will try it self\n      param = state.regexp && state.decode(path);\n      if(param){\n        return {\n          state: state,\n          param: param\n        }\n      }else{\n        return false;\n      }\n    },\n    _sortState: function( a, b ){\n      return ( b.priority || 0 ) - ( a.priority || 0 );\n    },\n    // find the same branch;\n    _findBase: function(now, before){\n\n      if(!now || !before || now == this || before == this) return this;\n      var np = now, bp = before, tmp;\n      while(np && bp){\n        tmp = bp;\n        while(tmp){\n          if(np === tmp) return tmp;\n          tmp = tmp.parent;\n        }\n        np = np.parent;\n      }\n    },\n\n}, true);\n\nmodule.exports = BaseMan;\n\n"},"hash":"35525c31595851bab3dfc7d9a7204741"}