{"dependencies":[{"name":"./helper/diff","loc":{"line":1,"column":24}},{"name":"./helper/combine","loc":{"line":2,"column":22}},{"name":"./helper/animate","loc":{"line":3,"column":22}},{"name":"./parser/Parser","loc":{"line":4,"column":21}},{"name":"./parser/node","loc":{"line":5,"column":19}},{"name":"./group","loc":{"line":6,"column":20}},{"name":"./dom","loc":{"line":7,"column":18}},{"name":"./util","loc":{"line":8,"column":16}},{"name":"./const","loc":{"line":9,"column":21}},{"name":"./helper/cursor","loc":{"line":13,"column":25}},{"name":"./config","loc":{"line":14,"column":21}},{"name":"./render/shared","loc":{"line":15,"column":21}}],"generated":{"js":"var diffArray = require('./helper/diff').diffArray;\nvar combine = require('./helper/combine');\nvar animate = require(\"./helper/animate\");\nvar Parser = require('./parser/Parser');\nvar node = require(\"./parser/node\");\nvar Group = require('./group');\nvar dom = require(\"./dom\");\nvar _ = require('./util');\nvar consts = require('./const');\nvar OPTIONS = consts.OPTIONS;\nvar ERROR = consts.ERROR;\nvar MSG = consts.MSG;\nvar nodeCursor = require('./helper/cursor');\nvar config = require('./config')\nvar shared = require('./render/shared');\n\n\n\nvar walkers = module.exports = {};\n\n\n\n// used in walkers.list\n// remove block in group\nfunction removeRange(index, rlen, children){\n  for(var j = 1; j <= rlen; j++){ //removed\n    var removed = children[ index + j ];\n    if(removed) removed.destroy(true);\n  }\n  children.splice(index+1, rlen);\n}\n\n\nwalkers.list = function(ast, options){\n\n  var Regular = walkers.Regular;\n  var placeholder = document.createComment(\"Regular list\"),\n    namespace = options.namespace,\n    extra = options.extra;\n\n  var self = this;\n  var group = new Group([placeholder]);\n  var children = group.children;\n\n  var indexName = ast.variable + '_index';\n  var keyName = ast.variable + '_key';\n  var variable = ast.variable;\n  var alternate = ast.alternate;\n  var track = ast.track, keyOf, extraObj;\n  var cursor = options.cursor;\n\n  insertPlaceHolder(placeholder, cursor)\n\n\n  if( track && track !== true ){\n\n    track = this._touchExpr(track);\n    extraObj = _.createObject(extra);\n    keyOf = function( item, index ){\n      extraObj[ variable ] = item;\n      extraObj[ indexName ] = index;\n      // @FIX keyName\n      return track.get( self, extraObj );\n    }\n  }\n\n  function addRange(index, end, newList, rawNewValue){\n    for(var o = index; o < end; o++){ //add\n      // prototype inherit\n      var item = newList[o];\n      var data = _.createObject(extra);\n      updateTarget(data, o, item, rawNewValue);\n\n      var section = self.$compile(ast.body, {\n        extra: data,\n        namespace:namespace,\n        record: true,\n        outer: options.outer,\n        cursor: cursor\n      })\n      section.data = data;\n      // autolink\n      var insert =  combine.last(group.get(o));\n      if(insert.parentNode && !cursor ){\n        animate.inject(combine.node(section),insert, 'after');\n      }\n      // insert.parentNode.insertBefore(combine.node(section), insert.nextSibling);\n      children.splice( o + 1 , 0, section);\n    }\n  }\n\n  function updateTarget(target, index, item, rawNewValue){\n      target[ indexName ] = index;\n      if( rawNewValue ){\n        target[ keyName ] = item;\n        target[ variable ] = rawNewValue[ item ];\n      }else{\n        target[ variable ] = item;\n        target[keyName] = null\n      }\n  }\n\n\n  function updateRange(start, end, newList, rawNewValue){\n    for(var k = start; k < end; k++){ // no change\n      var sect = group.get( k + 1 ), item = newList[ k ];\n      updateTarget(sect.data, k, item, rawNewValue);\n    }\n  }\n\n  function updateLD(newList, oldList, splices , rawNewValue ){\n\n    var cur = placeholder;\n    var m = 0, len = newList.length;\n\n    if(!splices && (len !==0 || oldList.length !==0)  ){\n      splices = diffArray(newList, oldList, true);\n    }\n\n    if(!splices || !splices.length) return;\n\n    for(var i = 0; i < splices.length; i++){ //init\n      var splice = splices[i];\n      var index = splice.index; // beacuse we use a comment for placeholder\n      var removed = splice.removed;\n      var add = splice.add;\n      var rlen = removed.length;\n      // for track\n      if( track && rlen && add ){\n        var minar = Math.min(rlen, add);\n        var tIndex = 0;\n        while(tIndex < minar){\n          if( keyOf(newList[index], index) !== keyOf( removed[0], index ) ){\n            removeRange(index, 1, children)\n            addRange(index, index+1, newList, rawNewValue)\n          }\n          removed.shift();\n          add--;\n          index++;\n          tIndex++;\n        }\n        rlen = removed.length;\n      }\n      // update\n      updateRange(m, index, newList, rawNewValue);\n\n      removeRange( index ,rlen, children)\n\n      addRange(index, index+add, newList, rawNewValue)\n\n      m = index + add - rlen;\n      m  = m < 0? 0 : m;\n\n    }\n    if(m < len){\n      for(var i = m; i < len; i++){\n        var pair = group.get(i + 1);\n        pair.data[indexName] = i;\n        // @TODO fix keys\n      }\n    }\n  }\n\n  // if the track is constant test.\n  function updateSimple(newList, oldList, rawNewValue ){\n\n    var nlen = newList.length;\n    var olen = oldList.length;\n    var mlen = Math.min(nlen, olen);\n\n    updateRange(0, mlen, newList, rawNewValue)\n    if(nlen < olen){ //need add\n      removeRange(nlen, olen-nlen, children);\n    }else if(nlen > olen){\n      addRange(olen, nlen, newList, rawNewValue);\n    }\n  }\n\n  function update(newValue, oldValue, splices){\n\n    var nType = _.typeOf( newValue );\n    var oType = _.typeOf( oldValue );\n\n    var newList = getListFromValue( newValue, nType );\n    var oldList = getListFromValue( oldValue, oType );\n\n    var rawNewValue;\n\n\n    var nlen = newList && newList.length;\n    var olen = oldList && oldList.length;\n\n    // if previous list has , we need to remove the altnated section.\n    if( !olen && nlen && group.get(1) ){\n      var altGroup = children.pop();\n      if(altGroup.destroy)  altGroup.destroy(true);\n    }\n\n    if( nType === 'object' ) rawNewValue = newValue;\n\n    if(track === true){\n      updateSimple( newList, oldList,  rawNewValue );\n    }else{\n      updateLD( newList, oldList, splices, rawNewValue );\n    }\n\n    // @ {#list} {#else}\n    if( !nlen && alternate && alternate.length){\n      var section = self.$compile(alternate, {\n        extra: extra,\n        record: true,\n        outer: options.outer,\n        namespace: namespace\n      })\n      children.push(section);\n      if(placeholder.parentNode){\n        animate.inject(combine.node(section), placeholder, 'after');\n      }\n    }\n  }\n\n  this.$watch(ast.sequence, update, {\n    init: true,\n    diff: track !== true ,\n    deep: true\n  });\n  //@FIXIT, beacuse it is sync process, we can\n  cursor = null;\n  return group;\n}\n\n\n\n// {#include } or {#inc template}\nwalkers.template = function(ast, options){\n  var content = ast.content, compiled;\n  var placeholder = document.createComment('inlcude');\n  var compiled, namespace = options.namespace, extra = options.extra;\n  var group = new Group([placeholder]);\n  var cursor = options.cursor;\n\n  insertPlaceHolder(placeholder, cursor);\n\n  if(content){\n    var self = this;\n    this.$watch(content, function(value){\n      var removed = group.get(1), type= typeof value;\n      if( removed){\n        removed.destroy(true);\n        group.children.pop();\n      }\n      if(!value) return;\n\n      group.push( compiled = type === 'function' ? value(cursor? {cursor: cursor}: null): self.$compile( type !== 'object'? String(value): value, {\n        record: true,\n        outer: options.outer,\n        namespace: namespace,\n        cursor: cursor,\n        extra: extra}) );\n      if(placeholder.parentNode && !cursor) {\n        compiled.$inject(placeholder, 'before')\n      }\n    }, OPTIONS.INIT);\n    cursor = null;\n  }\n  return group;\n};\n\nfunction getListFromValue(value, type){\n  return type === 'array'? value: (type === 'object'? _.keys(value) :  []);\n}\n\n\n// how to resolve this problem\nvar ii = 0;\nwalkers['if'] = function(ast, options){\n  var self = this, consequent, alternate, extra = options.extra;\n  if(options && options.element){ // attribute inteplation\n    var update = function(nvalue){\n      if(!!nvalue){\n        if(alternate) combine.destroy(alternate)\n        if(ast.consequent) consequent = self.$compile(ast.consequent, {\n          record: true,\n          element: options.element ,\n          extra:extra\n        });\n      }else{\n        if( consequent ) combine.destroy(consequent)\n        if( ast.alternate ) alternate = self.$compile(ast.alternate, {record: true, element: options.element, extra: extra});\n      }\n    }\n    this.$watch(ast.test, update, OPTIONS.FORCE);\n    return {\n      destroy: function(){\n        if(consequent) combine.destroy(consequent);\n        else if(alternate) combine.destroy(alternate);\n      }\n    }\n  }\n\n  var test, node;\n  var placeholder = document.createComment(\"Regular if\" + ii++);\n  var group = new Group();\n  group.push(placeholder);\n  var preValue = null, namespace= options.namespace;\n  var cursor = options.cursor;\n  insertPlaceHolder(placeholder, cursor)\n\n  var update = function (nvalue, old){\n    var value = !!nvalue, compiledSection;\n    if(value === preValue) return;\n    preValue = value;\n    if(group.children[1]){\n      group.children[1].destroy(true);\n      group.children.pop();\n    }\n    var curOptions = {\n      record: true,\n      outer: options.outer,\n      namespace: namespace,\n      extra: extra,\n      cursor: cursor\n    }\n    if(value){ //true\n\n      if(ast.consequent && ast.consequent.length){\n        compiledSection = self.$compile( ast.consequent , curOptions );\n      }\n    }else{ //false\n      if(ast.alternate && ast.alternate.length){\n        compiledSection = self.$compile(ast.alternate, curOptions);\n      }\n    }\n    // placeholder.parentNode && placeholder.parentNode.insertBefore( node, placeholder );\n    if(compiledSection){\n      group.push(compiledSection );\n      if(placeholder.parentNode && !cursor){\n        animate.inject(combine.node(compiledSection), placeholder, 'before');\n      }\n    }\n    cursor = null;\n    // after first mount , we need clear this flat;\n  }\n  this.$watch(ast.test, update, OPTIONS.FORCE_INIT);\n\n  return group;\n}\n\n\nwalkers._handleMountText = function(cursor, astText){\n    var node, mountNode = cursor.node;\n    // fix unused black in astText;\n    var nodeText = dom.text(mountNode);\n\n    if( nodeText === astText ){\n      node = mountNode;\n      cursor.next();\n    }else{\n      // maybe have some redundancy  blank\n      var index = nodeText.indexOf(astText);\n      if(~index){\n        node = document.createTextNode(astText);\n        dom.text( mountNode, nodeText.slice(index + astText.length) );\n        dom.inject(node, mountNode, 'before');\n      } else {\n        // if( _.blankReg.test( astText ) ){ }\n        throw Error( MSG[ERROR.UNMATCHED_AST]);\n      }\n    }\n\n    return node;\n}\n\n\nwalkers.expression = function(ast, options){\n\n  var cursor = options.cursor, node,\n    mountNode = cursor && cursor.node;\n\n  if(mountNode){\n    //@BUG: if server render &gt; in Expression will cause error\n    var astText = _.toText( this.$get(ast) );\n    node = walkers._handleMountText(cursor, astText);\n\n  }else{\n    node = document.createTextNode(\"\");\n  }\n\n  this.$watch(ast, function(newval){\n    dom.text(node, _.toText(newval));\n  }, OPTIONS.STABLE_INIT )\n  return node;\n\n}\n\n\nwalkers.text = function(ast, options){\n  var cursor = options.cursor , node;\n  var text = ast.text;\n  var astText = text.indexOf('&') !== -1? _.convertEntity(text): text;\n\n  if(cursor && cursor.node) {\n    var mountNode = cursor.node;\n    // maybe regularjs parser have some difference with html builtin parser when process  empty text\n    // @todo error report\n    if(mountNode.nodeType !== 3 ){\n\n      if( _.blankReg.test(astText) ) return {\n        code:  ERROR.UNMATCHED_AST\n      }\n\n    }else{\n      node = walkers._handleMountText( cursor, astText )\n    }\n  }\n\n\n  return node || document.createTextNode( astText );\n}\n\n\n\n\n/**\n * walkers element (contains component)\n */\nwalkers.element = function(ast, options){\n\n  var attrs = ast.attrs, self = this,\n    Constructor = this.constructor,\n    children = ast.children,\n    namespace = options.namespace,\n    extra = options.extra,\n    cursor = options.cursor,\n    tag = ast.tag,\n    Component = Constructor.component(tag),\n    ref, group, element, mountNode;\n    \n\n\n\n  if( tag === 'r-content' ){\n    _.log('r-content is deprecated, use {#inc this.$body} instead (`{#include}` as same)', 'warn');\n    return this.$body && this.$body(cursor? {cursor: cursor}: null);\n  }\n\n\n  // if inititalized with mount mode, sometime, \n  // browser will ignore the whitespace between node, and sometimes it won't\n  if(cursor ){\n    // textCOntent with Empty text\n    if(cursor.node && cursor.node.nodeType === 3){\n      if(_.blankReg.test(dom.text(cursor.node) ) ) cursor.next();\n      else if( !Component && tag !== 'r-component' ) {\n        throw Error(MSG[ERROR.UNMATCHED_AST]);\n      } \n    }\n  }\n  \n  if(Component || tag === 'r-component'){\n    options.Component = Component;\n    return walkers.component.call(this, ast, options)\n  }\n\n  if(cursor) mountNode = cursor.node;\n\n  if(tag === 'svg') namespace = \"svg\";\n  // @Deprecated: may be removed in next version, use {#inc } instead\n\n  if( children && children.length && !hasStopDirective( attrs ) ){\n\n    var subMountNode = mountNode? mountNode.firstChild: null;\n    group = this.$compile(children, {\n      extra: extra ,\n      outer: options.outer,\n      namespace: namespace,\n      cursor: nodeCursor( subMountNode, mountNode )\n    });\n  }\n\n\n  if(mountNode){\n    element = mountNode\n    cursor.next();\n  }else{\n    element = dom.create( tag, namespace, attrs);\n  }\n\n  if(group && !_.isVoidTag( tag ) && !mountNode ){ // if not init with mount mode\n    animate.inject( combine.node( group ) , element)\n  }\n\n  // fix tag ast, some infomation only avaliable at runtime (directive etc..)\n  _.fixTagAST(ast, Constructor)\n\n  var destroies = walkAttributes.call(this, attrs, element, extra);\n\n  return {\n    type: \"element\",\n    group: group,\n    node: function(){\n      return element;\n    },\n    last: function(){\n      return element;\n    },\n    destroy: function(first){\n      if( first ){\n        animate.remove( element, group? group.destroy.bind( group ): _.noop );\n      }else if(group) {\n        group.destroy();\n      }\n      // destroy ref\n      if( destroies.length ) {\n        destroies.forEach(function( destroy ){\n          if( destroy ){\n            if( typeof destroy.destroy === 'function' ){\n              destroy.destroy()\n            }else{\n              destroy();\n            }\n          }\n        })\n      }\n    }\n  }\n}\n\n\n\nwalkers.component = function(ast, options){\n  var attrs = ast.attrs,\n    Component = options.Component,\n    cursor = options.cursor,\n    Constructor = this.constructor,\n    isolate,\n    extra = options.extra,\n    namespace = options.namespace,\n    refDirective = walkers.Regular.directive('ref'),\n    ref, self = this, is;\n\n  var data = {}, events;\n\n  for(var i = 0, len = attrs.length; i < len; i++){\n    var attr = attrs[i];\n    // consider disabled   equlasto  disabled={true}\n\n    shared.prepareAttr( attr, attr.name === 'ref' && refDirective );\n\n    var value = this._touchExpr(attr.value === undefined? true: attr.value);\n    if(value.constant) value = attr.value = value.get(this);\n    if(attr.value && attr.value.constant === true){\n      value = value.get(this);\n    }\n    var name = attr.name;\n    if(!attr.event){\n      var etest = name.match(_.eventReg);\n      // event: 'nav'\n      if(etest) attr.event = etest[1];\n    }\n\n\n    // @deprecated  use \n    if(attr.mdf === 'cmpl'){\n      value = _.getCompileFn(value, this, {\n        record: true,\n        namespace:namespace,\n        extra: extra,\n        outer: options.outer\n      })\n    }\n\n    // title = {~ <h2>{name}</h2>}\n    if(value && value.type === 'body'){\n      value = _.getCompileFn(value.body, this, {\n        record: true,\n        namespace: namespace,\n        extra: extra,\n        outer: options.outer\n      }) \n    }\n\n    // @if is r-component . we need to find the target Component\n    if(name === 'is' && !Component){\n      is = value;\n      var componentName = this.$get(value, true);\n      Component = Constructor.component(componentName)\n      if(typeof Component !== 'function') throw new Error(\"component \" + componentName + \" has not registed!\");\n    }\n    // bind event proxy\n    var eventName;\n    if(eventName = attr.event){\n      events = events || {};\n      events[eventName] = _.handleEvent.call(this, value, eventName);\n      continue;\n    }else {\n      name = attr.name = _.camelCase( name );\n    }\n\n    if(!value || value.type !== 'expression'){\n      data[name] = value;\n    }else{\n      data[name] = value.get(self);\n    }\n    if( name === 'ref'  && value != null){\n      ref = value\n    }\n    if( name === 'isolate'){\n      // 1: stop: composite -> parent\n      // 2. stop: composite <- parent\n      // 3. stop 1 and 2: composite <-> parent\n      // 0. stop nothing (defualt)\n      isolate = value.type === 'expression'? value.get(self): parseInt(value === true? 3: value, 10);\n      data.isolate = isolate;\n    }\n  }\n\n  var definition = {\n    data: data,\n    events: events,\n    $parent: (isolate & 2)? null: this,\n    $root: this.$root,\n    $outer: options.outer,\n    _body: {\n      ctx: this,\n      ast: ast.children\n    }\n  }\n  var options = {\n    namespace: namespace,\n    cursor: cursor,\n    extra: options.extra\n  }\n\n\n  var component = new Component(definition, options), reflink;\n\n\n  if(ref && this.$refs){\n    reflink = refDirective.link;\n    var refDestroy = reflink.call(this, component, ref);\n    component.$on('$destroy', refDestroy);\n  }\n  for(var i = 0, len = attrs.length; i < len; i++){\n    var attr = attrs[i];\n    var value = attr.value||true;\n    var name = attr.name;\n    // need compiled\n    if(value.type === 'expression' && !attr.event){\n      value = self._touchExpr(value);\n      // use bit operate to control scope\n      if( !(isolate & 2) )\n        this.$watch(value, (function(name, val){\n          this.data[name] = val;\n        }).bind(component, name), OPTIONS.SYNC)\n      if( value.set && !(isolate & 1 ) )\n        // sync the data. it force the component don't trigger attr.name's first dirty echeck\n        component.$watch(name, self.$update.bind(self, value), OPTIONS.INIT);\n    }\n  }\n  if(is && is.type === 'expression'  ){\n    var group = new Group();\n    group.push(component);\n    this.$watch(is, function(value){\n      // found the new component\n      var Component = Constructor.component(value);\n      if(!Component) throw new Error(\"component \" + value + \" has not registed!\");\n      var ncomponent = new Component(definition);\n      var component = group.children.pop();\n      group.push(ncomponent);\n      ncomponent.$inject(combine.last(component), 'after')\n      component.destroy();\n      // @TODO  if component changed , we need update ref\n      if(ref){\n        var refName = ref.get? ref.get(this): ref;\n        self.$refs[refName] = ncomponent;\n      }\n    }, OPTIONS.SYNC)\n    return group;\n  }\n  return component;\n}\n\nfunction walkAttributes(attrs, element, extra){\n  var bindings = []\n  for(var i = 0, len = attrs.length; i < len; i++){\n    var binding = this._walk(attrs[i], {element: element, fromElement: true, attrs: attrs, extra: extra})\n    if(binding) bindings.push(binding);\n  }\n  return bindings;\n}\n\n\nwalkers.attribute = function(ast ,options){\n\n  var attr = ast;\n  var Component = this.constructor;\n  var name = attr.name;\n  var directive = Component.directive(name);\n\n  shared.prepareAttr(ast, directive);\n\n  var value = attr.value || \"\";\n  var constant = value.constant;\n  var element = options.element;\n  var self = this;\n\n\n\n  value = this._touchExpr(value);\n\n  if(constant) value = value.get(this);\n\n  if(directive && directive.link){\n    var extra = {\n      attrs: options.attrs,\n      param: _.getParamObj(this, attr.param)\n    }\n    var binding = directive.link.call(self, element, value, name, extra);\n    // if update has been passed in , we will  automately watch value for user\n    if( typeof directive.update === 'function'){\n      if(_.isExpr(value)){\n        this.$watch(value, function(val, old){\n          directive.update.call(self, element, val, old, extra);\n        })\n      }else{\n        directive.update.call(self, element, value, undefined, extra );\n      }\n    }\n    if(typeof binding === 'function') binding = {destroy: binding};\n    return binding;\n  } else{\n    if(value.type === 'expression' ){\n      this.$watch(value, function(nvalue, old){\n        dom.attr(element, name, nvalue);\n      }, OPTIONS.STABLE_INIT);\n    }else{\n      if(_.isBooleanAttr(name)){\n        dom.attr(element, name, true);\n      }else{\n        dom.attr(element, name, value);\n      }\n    }\n    if(!options.fromElement){\n      return {\n        destroy: function(){\n          dom.attr(element, name, null);\n        }\n      }\n    }\n  }\n}\n\nfunction insertPlaceHolder(placeholder, cursor){\n  if(cursor){\n    if(cursor.node) dom.inject( placeholder , cursor.node,'before')\n    else if(cursor.prev) {\n      dom.inject( placeholder , cursor.prev,'after')\n      cursor.prev = placeholder;\n    }else if(cursor.parent){\n      dom.inject( placeholder , cursor.parent)\n      cursor.prev = placeholder\n    }\n  }\n}\n\n\n// @FIXIT\nfunction hasStopDirective(attrs){\n  for( var i = attrs.length; i--; ){\n    var attr = attrs[i];\n    if(attr.name === 'r-html') return true;\n  }\n}\n"},"hash":"396c2c6ff2b3b58c53963e13b79f8d61"}