{"dependencies":[{"name":"../util.js","loc":{"line":3,"column":16}}],"generated":{"js":"// simplest event emitter 60 lines\n// ===============================\nvar _ = require(\"../util.js\");\nvar fallbackEvent = {\n  destory: '$destory',\n  update: '$update',\n  init: '$init',\n  config: '$config'\n}\n\n// to fix 0.2.x version event\n// map init to $init;\n// @FIXIT after version 1.0\nfunction fix(type){\n  return fallbackEvent[type] || type\n}\nvar API = {\n  $on: function(event, fn, desc) {\n    if(typeof event === \"object\" && event){\n      for (var i in event) {\n        this.$on(i, event[i], fn);\n      }\n    }else{\n      desc = desc || {};\n      // @patch: for list\n      var context = this;\n      event = fix(event);\n      var handles = context._handles || (context._handles = {}),\n        calls = handles[event] || (handles[event] = []);\n      var realFn;\n      if(desc.once){\n        realFn = function(){\n          fn.apply( this, arguments )\n          this.$off(event, fn);\n        }\n        // @FIX: if  same fn\n        fn.real = realFn;\n      }\n      calls.push( realFn || fn );\n    }\n    return this;\n  },\n  $off: function(event, fn) {\n    var context = this;\n    if(!context._handles) return;\n    if(!event) this._handles = {};\n    var handles = context._handles,\n      calls;\n\n    event = fix(event);\n    if (calls = handles[event]) {\n      if (!fn) {\n        handles[event] = [];\n        return context;\n      }\n      fn = fn.real || fn;\n      for (var i = 0, len = calls.length; i < len; i++) {\n        if (fn === calls[i]) {\n          calls.splice(i, 1);\n          return context;\n        }\n      }\n    }\n    return context;\n  },\n  // bubble event\n  $emit: function(event){\n    // @patch: for list\n    var context = this;\n    var handles = context._handles, calls, args, type;\n    if(!event) return;\n    var args = _.slice(arguments, 1);\n    var type = fix(event);\n\n    if(!handles) return context;\n    if (!(calls = handles[type])) return context;\n\n    if(calls.length > 1){ // handle, when first is off the event\n      calls = calls.slice();\n    }\n    \n    for (var i = 0, len = calls.length; i < len; i++) {\n      if(typeof calls[i] === 'function') calls[i].apply(context, args)\n    }\n    return context;\n  },\n  // capture  event\n  $once: function(event, fn){\n    var args = _.slice(arguments);\n    args.push({once: true})\n    return this.$on.apply(this, args);\n  }\n}\n// container class\nfunction Event() {}\n_.extend(Event.prototype, API)\n\nEvent.mixTo = function(obj){\n  obj = typeof obj === \"function\" ? obj.prototype : obj;\n  _.extend(obj, API)\n}\nmodule.exports = Event;\n"},"hash":"4d5eadd2076dee17a9a55715f648ab65"}