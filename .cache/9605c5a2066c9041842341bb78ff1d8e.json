{"dependencies":[{"name":"../util","loc":{"line":2,"column":16}},{"name":"../dom","loc":{"line":3,"column":18}},{"name":"../const","loc":{"line":4,"column":22}},{"name":"../render/client","loc":{"line":7,"column":22}}],"generated":{"js":"// Regular\nvar _ = require(\"../util\");\nvar dom = require(\"../dom\");\nvar OPTIONS = require('../const').OPTIONS\nvar STABLE = OPTIONS.STABLE;\nvar hasInput;\nvar Regular = require(\"../render/client\");\n\nvar modelHandlers = {\n  \"text\": initText,\n  \"select\": initSelect,\n  \"checkbox\": initCheckBox,\n  \"radio\": initRadio\n}\n\n\n// @TODO\n\n\n// autoUpdate directive for select element\n// to fix r-model issue , when handle dynamic options\n\n\n/**\n * <select r-model={name}> \n *   <r-option value={value} ></r-option>\n * </select>\n */\n\n\n// two-way binding with r-model\n// works on input, textarea, checkbox, radio, select\n\n\nRegular.directive(\"r-model\", {\n  param: ['throttle', 'lazy'],\n  link: function( elem, value, name, extra ){\n    var tag = elem.tagName.toLowerCase();\n    var sign = tag;\n    if(sign === \"input\") sign = elem.type || \"text\";\n    else if(sign === \"textarea\") sign = \"text\";\n    if(typeof value === \"string\") value = this.$expression(value);\n\n    if( modelHandlers[sign] ) return modelHandlers[sign].call(this, elem, value, extra);\n    else if(tag === \"input\"){\n      return modelHandlers.text.call(this, elem, value, extra);\n    }\n  }\n  //@TODO\n  // ssr: function(name, value){\n  //   return value? \"value=\" + value: \"\"\n  // }\n});\n\n\n\n\n\n// binding <select>\n\nfunction initSelect( elem, parsed, extra){\n  var self = this;\n  var wc = this.$watch(parsed, function(newValue){\n    var children = elem.getElementsByTagName('option');\n    for(var i =0, len = children.length ; i < len; i++){\n      if(children[i].value == newValue){\n        elem.selectedIndex = i;\n        break;\n      }\n    }\n  }, STABLE);\n\n  function handler(){\n    parsed.set(self, this.value);\n    wc.last = this.value;\n    self.$update();\n  }\n  var isChanging = true \n  elem.__change = function(){\n    if(isChanging) return;\n    isChanging = true;\n    setTimeout(handler,0)\n  }\n\n  dom.on( elem, \"change\", handler );\n  \n  if(parsed.get(self) === undefined && elem.value){\n    parsed.set(self, elem.value);\n  }\n\n  return function destroy(){\n    dom.off(elem, \"change\", handler);\n    // remove __change function \n    delete elem.__change;\n  }\n}\n\n// input,textarea binding\nfunction initText(elem, parsed, extra){\n  var param = extra.param;\n  var throttle, lazy = param.lazy\n\n  if('throttle' in param){\n    // <input throttle r-model>\n    if(param[throttle] === true){\n      throttle = 400;\n    }else{\n      throttle = parseInt(param.throttle , 10)\n    }\n  }\n\n  var self = this;\n  var wc = this.$watch(parsed, function(newValue){\n    if(elem.value !== newValue) elem.value = newValue == null? \"\": \"\" + newValue;\n  }, STABLE);\n\n  // @TODO to fixed event\n  var handler = function (ev){\n    var that = this;\n    if(ev.type==='cut' || ev.type==='paste'){\n      _.nextTick(function(){\n        var value = that.value\n        parsed.set(self, value);\n        wc.last = value;\n        self.$update();\n      })\n    }else{\n        var value = that.value\n        parsed.set(self, value);\n        wc.last = value;\n        self.$update();\n    }\n  };\n\n  if(throttle && !lazy){\n    var preHandle = handler, tid;\n    handler = _.throttle(handler, throttle);\n  }\n\n  if(hasInput === undefined){\n    hasInput = dom.msie !== 9 && \"oninput\" in document.createElement('input')\n  }\n\n  if(lazy){\n    dom.on(elem, 'change', handler)\n  }else{\n    if( hasInput){\n      elem.addEventListener(\"input\", handler );\n    }else{\n      dom.on(elem, \"paste keyup cut change\", handler)\n    }\n  }\n  if(parsed.get(self) === undefined && elem.value){\n     parsed.set(self, elem.value);\n  }\n  return function (){\n    if(lazy) return dom.off(elem, \"change\", handler);\n    if( hasInput ){\n      elem.removeEventListener(\"input\", handler );\n    }else{\n      dom.off(elem, \"paste keyup cut change\", handler)\n    }\n  }\n}\n\n\n// input:checkbox  binding\n\nfunction initCheckBox(elem, parsed){\n  var self = this;\n  var watcher = this.$watch(parsed, function(newValue){\n    dom.attr(elem, 'checked', !!newValue);\n  }, STABLE);\n\n  var handler = function handler(){\n    var value = this.checked;\n    parsed.set(self, value);\n    watcher.last = value;\n    self.$update();\n  }\n  if(parsed.set) dom.on(elem, \"change\", handler)\n\n  if(parsed.get(self) === undefined){\n    parsed.set(self, !!elem.checked);\n  }\n\n  return function destroy(){\n    if(parsed.set) dom.off(elem, \"change\", handler)\n  }\n}\n\n\n// input:radio binding\n\nfunction initRadio(elem, parsed){\n  var self = this;\n  var wc = this.$watch(parsed, function( newValue ){\n    if(newValue == elem.value) elem.checked = true;\n    else elem.checked = false;\n  }, STABLE);\n\n\n  var handler = function handler(){\n    var value = this.value;\n    parsed.set(self, value);\n    self.$update();\n  }\n  if(parsed.set) dom.on(elem, \"change\", handler)\n  // beacuse only after compile(init), the dom structrue is exsit. \n  if(parsed.get(self) === undefined){\n    if(elem.checked) {\n      parsed.set(self, elem.value);\n    }\n  }\n\n  return function destroy(){\n    if(parsed.set) dom.off(elem, \"change\", handler)\n  }\n}\n\n\n\n"},"hash":"8c31c4b84ce578e3c5c90aec3c4a531f"}