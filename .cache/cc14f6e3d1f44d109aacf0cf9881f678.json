{"dependencies":[{"name":"./helper/shim","loc":{"line":1,"column":8}},{"name":"./helper/entities","loc":{"line":6,"column":23}},{"name":"./config","loc":{"line":10,"column":21}}],"generated":{"js":"var global = (1,eval)(\"this\");\nrequire('./helper/shim')();\n\n\n\nvar _  = module.exports;\nvar entities = require('./helper/entities');\nvar o2str = ({}).toString;\nvar win = typeof window !=='undefined'? window: global;\nvar MAX_PRIORITY = 9999;\nvar config = require('./config');\n\n\n_.noop = function(){};\n_.uid = (function(){\n  var _uid=0;\n  return function(){\n    return _uid++;\n  }\n})();\n\n_.extend = function( o1, o2, override ){\n  for(var i in o2) if (o2.hasOwnProperty(i)){\n    if( o1[i] === undefined || override === true ){\n      o1[i] = o2[i]\n    }\n  }\n  return o1;\n}\n\n_.keys = Object.keys? Object.keys: function(obj){\n  var res = [];\n  for(var i in obj) if(obj.hasOwnProperty(i)){\n    res.push(i);\n  }\n  return res;\n}\n\n_.some = function(list, fn){\n  for(var i =0,len = list.length; i < len; i++){\n    if(fn(list[i])) return true\n  }\n}\n\n_.varName = 'd';\n_.setName = 'p_';\n_.ctxName = 'c';\n_.extName = 'e';\n\n_.rWord = /^[\\$\\w]+$/;\n_.rSimpleAccessor = /^[\\$\\w]+(\\.[\\$\\w]+)*$/;\n\n_.nextTick = typeof setImmediate === 'function'? \n  setImmediate.bind(win) : \n  function(callback) {\n    setTimeout(callback, 0) \n  }\n\n\n\n_.prefix = \"'use strict';var \" + _.varName + \"=\" + _.ctxName + \".data;\" +  _.extName  + \"=\" + _.extName + \"||'';\";\n\n\n_.slice = function(obj, start, end){\n  var res = [];\n  for(var i = start || 0, len = end || obj.length; i < len; i++){\n    res.push(obj[i])\n  }\n  return res;\n}\n\n// beacuse slice and toLowerCase is expensive. we handle undefined and null in another way\n_.typeOf = function (o) {\n  return o == null ? String(o) :o2str.call(o).slice(8, -1).toLowerCase();\n}\n\n\n\n\n_.makePredicate = function makePredicate(words, prefix) {\n    if (typeof words === \"string\") {\n        words = words.split(\" \");\n    }\n    var f = \"\",\n    cats = [];\n    out: for (var i = 0; i < words.length; ++i) {\n        for (var j = 0; j < cats.length; ++j){\n          if (cats[j][0].length === words[i].length) {\n              cats[j].push(words[i]);\n              continue out;\n          }\n        }\n        cats.push([words[i]]);\n    }\n    function compareTo(arr) {\n        if (arr.length === 1) return f += \"return str === '\" + arr[0] + \"';\";\n        f += \"switch(str){\";\n        for (var i = 0; i < arr.length; ++i){\n           f += \"case '\" + arr[i] + \"':\";\n        }\n        f += \"return true}return false;\";\n    }\n\n    // When there are more than three length categories, an outer\n    // switch first dispatches on the lengths, to save on comparisons.\n    if (cats.length > 3) {\n        cats.sort(function(a, b) {\n            return b.length - a.length;\n        });\n        f += \"switch(str.length){\";\n        for (var i = 0; i < cats.length; ++i) {\n            var cat = cats[i];\n            f += \"case \" + cat[0].length + \":\";\n            compareTo(cat);\n        }\n        f += \"}\";\n\n        // Otherwise, simply generate a flat `switch` statement.\n    } else {\n        compareTo(words);\n    }\n    return new Function(\"str\", f);\n}\n\n\n_.trackErrorPos = (function (){\n  // linebreak\n  var lb = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n  var minRange = 20, maxRange = 20;\n  function findLine(lines, pos){\n    var tmpLen = 0;\n    for(var i = 0,len = lines.length; i < len; i++){\n      var lineLen = (lines[i] || \"\").length;\n\n      if(tmpLen + lineLen > pos) {\n        return {num: i, line: lines[i], start: pos - i - tmpLen , prev:lines[i-1], next: lines[i+1] };\n      }\n      // 1 is for the linebreak\n      tmpLen = tmpLen + lineLen ;\n    }\n  }\n  function formatLine(str,  start, num, target){\n    var len = str.length;\n    var min = start - minRange;\n    if(min < 0) min = 0;\n    var max = start + maxRange;\n    if(max > len) max = len;\n\n    var remain = str.slice(min, max);\n    var prefix = \"[\" +(num+1) + \"] \" + (min > 0? \"..\" : \"\")\n    var postfix = max < len ? \"..\": \"\";\n    var res = prefix + remain + postfix;\n    if(target) res += \"\\n\" + new Array(start-min + prefix.length + 1).join(\" \") + \"^^^\";\n    return res;\n  }\n  return function(input, pos){\n    if(pos > input.length-1) pos = input.length-1;\n    lb.lastIndex = 0;\n    var lines = input.split(lb);\n    var line = findLine(lines,pos);\n    var start = line.start, num = line.num;\n\n    return (line.prev? formatLine(line.prev, start, num-1 ) + '\\n': '' ) + \n      formatLine(line.line, start, num, true) + '\\n' + \n      (line.next? formatLine(line.next, start, num+1 ) + '\\n': '' );\n\n  }\n})();\n\n\nvar ignoredRef = /\\((\\?\\!|\\?\\:|\\?\\=)/g;\n_.findSubCapture = function (regStr) {\n  var left = 0,\n    right = 0,\n    len = regStr.length,\n    ignored = regStr.match(ignoredRef); // ignored uncapture\n  if(ignored) ignored = ignored.length\n  else ignored = 0;\n  for (; len--;) {\n    var letter = regStr.charAt(len);\n    if (len === 0 || regStr.charAt(len - 1) !== \"\\\\\" ) { \n      if (letter === \"(\") left++;\n      if (letter === \")\") right++;\n    }\n  }\n  if (left !== right) throw \"RegExp: \"+ regStr + \"'s bracket is not marched\";\n  else return left - ignored;\n};\n\n\n_.escapeRegExp = function( str){// Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License\n  return str.replace(/[-[\\]{}()*+?.\\\\^$|,#\\s]/g, function(match){\n    return '\\\\' + match;\n  });\n};\n\n\nvar rEntity = new RegExp(\"&(?:(#x[0-9a-fA-F]+)|(#[0-9]+)|(\" + _.keys(entities).join('|') + '));', 'gi');\n\n_.convertEntity = function(chr){\n\n  return (\"\" + chr).replace(rEntity, function(all, hex, dec, capture){\n    var charCode;\n    if( dec ) charCode = parseInt( dec.slice(1), 10 );\n    else if( hex ) charCode = parseInt( hex.slice(2), 16 );\n    else charCode = entities[capture]\n\n    return String.fromCharCode( charCode )\n  });\n\n}\n\n\n// simple get accessor\n\n_.createObject = Object.create? function(o){\n  return Object.create(o || null)\n}: (function(){\n    function Temp() {}\n    return function(o){\n      if(!o) return {}\n      Temp.prototype = o;\n      var obj = new Temp();\n      Temp.prototype = null; // 不要保持一个 O 的杂散引用（a stray reference）...\n      return obj\n    }\n})();\n\n_.createProto = function(fn, o){\n    function Foo() { this.constructor = fn;}\n    Foo.prototype = o;\n    return (fn.prototype = new Foo());\n}\n\n\n_.removeOne = function(list , filter){\n  var len = list.length;\n  for(;len--;){\n    if(filter(list[len])) {\n      list.splice(len, 1)\n      return;\n    }\n  }\n}\n\n\n/**\nclone\n*/\n_.clone = function clone(obj){\n  if(!obj || (typeof obj !== 'object' )) return obj;\n  if(Array.isArray(obj)){\n    var cloned = [];\n    for(var i=0,len = obj.length; i< len;i++){\n      cloned[i] = obj[i]\n    }\n    return cloned;\n  }else{\n    var cloned = {};\n    for(var i in obj) if(obj.hasOwnProperty(i)){\n      cloned[i] = obj[i];\n    }\n    return cloned;\n  }\n}\n\n_.equals = function(now, old){\n  var type = typeof now;\n  if(type === 'number' && typeof old === 'number'&& isNaN(now) && isNaN(old)) return true\n  return now === old;\n}\n\nvar dash = /-([a-z])/g;\n_.camelCase = function(str){\n  return str.replace(dash, function(all, capture){\n    return capture.toUpperCase();\n  })\n}\n\n\n\n_.throttle = function throttle(func, wait){\n  var wait = wait || 100;\n  var context, args, result;\n  var timeout = null;\n  var previous = 0;\n  var later = function() {\n    previous = +new Date;\n    timeout = null;\n    result = func.apply(context, args);\n    context = args = null;\n  };\n  return function() {\n    var now = + new Date;\n    var remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(context, args);\n      context = args = null;\n    } else if (!timeout) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n};\n\n// hogan escape\n// ==============\n_.escape = (function(){\n  var rAmp = /&/g,\n      rLt = /</g,\n      rGt = />/g,\n      rApos = /\\'/g,\n      rQuot = /\\\"/g,\n      hChars = /[&<>\\\"\\']/;\n\n  return function(str) {\n    return hChars.test(str) ?\n      str\n        .replace(rAmp, '&amp;')\n        .replace(rLt, '&lt;')\n        .replace(rGt, '&gt;')\n        .replace(rApos, '&#39;')\n        .replace(rQuot, '&quot;') :\n      str;\n  }\n})();\n\n_.cache = function(max){\n  max = max || 1000;\n  var keys = [],\n      cache = {};\n  return {\n    set: function(key, value) {\n      if (keys.length > this.max) {\n        cache[keys.shift()] = undefined;\n      }\n      // \n      if(cache[key] === undefined){\n        keys.push(key);\n      }\n      cache[key] = value;\n      return value;\n    },\n    get: function(key) {\n      if (key === undefined) return cache;\n      return cache[key];\n    },\n    max: max,\n    len:function(){\n      return keys.length;\n    }\n  };\n}\n\n// // setup the raw Expression\n\n\n// handle the same logic on component's `on-*` and element's `on-*`\n// return the fire object\n_.handleEvent = function(value, type ){\n  var self = this, evaluate;\n  if(value.type === 'expression'){ // if is expression, go evaluated way\n    evaluate = value.get;\n  }\n  if(evaluate){\n    return function fire(obj){\n      self.$update(function(){\n        var data = this.data;\n        data.$event = obj;\n        var res = evaluate(self);\n        if(res === false && obj && obj.preventDefault) obj.preventDefault();\n        data.$event = undefined;\n      })\n\n    }\n  }else{\n    return function fire(){\n      var args = _.slice(arguments);\n      args.unshift(value);\n      self.$update(function(){\n        self.$emit.apply(self, args);\n      })\n    }\n  }\n}\n\n// only call once\n_.once = function(fn){\n  var time = 0;\n  return function(){\n    if( time++ === 0) fn.apply(this, arguments);\n  }\n}\n\n_.fixObjStr = function(str){\n  if(str.trim().indexOf('{') !== 0){\n    return '{' + str + '}';\n  }\n  return str;\n}\n\n\n_.map= function(array, callback){\n  var res = [];\n  for (var i = 0, len = array.length; i < len; i++) {\n    res.push(callback(array[i], i));\n  }\n  return res;\n}\n\nfunction log(msg, type){\n  if(typeof console !== \"undefined\")  console[type || \"log\"](msg);\n}\n\n_.log = log;\n\n\n_.normListener = function( events  ){\n    var eventListeners = [];\n    var pType = _.typeOf( events );\n    if( pType === 'array' ){\n      return events;\n    }else if ( pType === 'object' ){\n      for( var i in events ) if ( events.hasOwnProperty(i) ){\n        eventListeners.push({\n          type: i,\n          listener: events[i]\n        })\n      }\n    }\n    return eventListeners;\n}\n\n\n//http://www.w3.org/html/wg/drafts/html/master/single-page.html#void-elements\n_.isVoidTag = _.makePredicate(\"area base br col embed hr img input keygen link menuitem meta param source track wbr r-content\");\n_.isBooleanAttr = _.makePredicate('selected checked disabled readonly required open autofocus controls autoplay compact loop defer multiple');\n\n\n_.isExpr = function(expr){\n  return expr && expr.type === 'expression';\n}\n// @TODO: make it more strict\n_.isGroup = function(group){\n  return group.inject || group.$inject;\n}\n\n_.blankReg = /^\\s*$/; \n\n_.getCompileFn = function(source, ctx, options){\n  return function( passedOptions ){\n    if( passedOptions && options ) _.extend( passedOptions , options );\n    else passedOptions = options;\n    return ctx.$compile(source, passedOptions )\n  }\n  return ctx.$compile.bind(ctx,source, options)\n}\n\n// remove directive param from AST\n_.fixTagAST = function( tagAST, Component ){\n\n  if( tagAST.touched ) return;\n\n  var attrs = tagAST.attrs;\n\n  if( !attrs ) return;\n\n  // Maybe multiple directive need same param, \n  // We place all param in totalParamMap\n  var len = attrs.length;\n  if(!len) return;\n  var directives=[], otherAttrMap = {};\n  for(;len--;){\n\n    var attr = attrs[ len ];\n\n\n    // @IE fix IE9- input type can't assign after value\n    if(attr.name === 'type') attr.priority = MAX_PRIORITY + 1;\n\n    var directive = Component.directive( attr.name );\n    if( directive ) {\n\n      attr.priority = directive.priority || 1;\n      attr.directive = true;\n      directives.push(attr);\n\n    }else if(attr.type === 'attribute'){\n      otherAttrMap[attr.name] = attr.value;\n    }\n  }\n\n  directives.forEach( function( attr ){\n    var directive = Component.directive(attr.name);\n    var param = directive.param;\n    if(param && param.length){\n      attr.param = {};\n      param.forEach(function( name ){\n        if( name in otherAttrMap ){\n          attr.param[name] = otherAttrMap[name] === undefined? true: otherAttrMap[name]\n          _.removeOne(attrs, function(attr){\n            return attr.name === name\n          })\n        }\n      })\n    }\n  });\n\n  attrs.sort(function(a1, a2){\n    \n    var p1 = a1.priority;\n    var p2 = a2.priority;\n\n    if( p1 == null ) p1 = MAX_PRIORITY;\n    if( p2 == null ) p2 = MAX_PRIORITY;\n\n    return p2 - p1;\n\n  })\n\n  tagAST.touched = true;\n}\n\n_.findItem = function(list, filter){\n  if(!list || !list.length) return;\n  var len = list.length;\n  while(len--){\n    if(filter(list[len])) return list[len]\n  }\n}\n\n_.getParamObj = function(component, param){\n  var paramObj = {};\n  if(param) {\n    for(var i in param) if(param.hasOwnProperty(i)){\n      var value = param[i];\n      paramObj[i] =  value && value.type==='expression'? component.$get(value): value;\n    }\n  }\n  return paramObj;\n}\n_.eventReg = /^on-(\\w[-\\w]+)$/;\n\n_.toText = function(obj){\n  return obj == null ? \"\": \"\" + obj;\n}\n\n\n// hogan\n// https://github.com/twitter/hogan.js\n// MIT\n_.escape = (function(){\n  var rAmp = /&/g,\n      rLt = /</g,\n      rGt = />/g,\n      rApos = /\\'/g,\n      rQuot = /\\\"/g,\n      hChars = /[&<>\\\"\\']/;\n\n  function ignoreNullVal(val) {\n    return String((val === undefined || val == null) ? '' : val);\n  }\n\n  return function (str) {\n    str = ignoreNullVal(str);\n    return hChars.test(str) ?\n      str\n        .replace(rAmp, '&amp;')\n        .replace(rLt, '&lt;')\n        .replace(rGt, '&gt;')\n        .replace(rApos, '&#39;')\n        .replace(rQuot, '&quot;') :\n      str;\n  }\n\n})();\n\n\n\n\n\n\n\n"},"hash":"66b02cde6b26d7ba0a2a65633926ff29"}